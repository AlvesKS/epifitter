---
title: "Fitting disease progress curves to classic epidemiological models"
author: "Kaique S Alves"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Fitting disease progress curves to classic epidemiological models}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
# Introduction

Use `epifitter` to fit the classic epidemiological models, *Exponential*, *Monomolecular*, *Logistic*, *Gompertz*, to your disease progress curves (DPCs). This package is optimized to fit theses models using data linearization approach using the function `fit_lin` and nonlinear regression using the functions `fit_nlin` and `fit_nlin2`. And if you have tons of DPCs in your dataset, I would recommend to you to use the `multi_fitter()` function, which can fit all theses model to each of your DPCs.

In this vignette I will demonstrate the main features about these functions, using them in some simulated data. I hope you appreciate it. Have fun!

# Hands on
## Packages

First we have to load some packages. If you don't have any of theses, please install it with the function `install.packages()`.

```{r message=FALSE, warning=FALSE}
library(epifitter)
library(ggplot2)
library(dplyr)
```


## Data

To demonstrate the fitting procedure, first we need some data. Let's use the function `sim_logistic` to do that. You can check on `?sim_logistic` to see details about this function.

```{r}
dpc_data <- sim_logistic(
  N = 100,
  y0 = 0.01,
  dt = 5,
  r = 0.1,
  alpha = 0.2,
  n = 7
)
head(dpc_data)
```

## Using `fit_lin()` to fit DPCs using data linearization 

The `fit_lin()` function fits DPCs to classic epidemiological models using linearization of the disease intensity. To use this function you need to provide the following arguments: 
 
* `time`: A vector containing time steps of the DPCs.
* `y`: A vector with the disease intensity data.

In our data `dpc_data` we can call these vectors using the `$` operator, like bellow:

```{r}
f_lin <- fit_lin(time = dpc_data$time,
                 y = dpc_data$random_y)
f_lin
```

#### So what?
Note the first part of the output we have the `Stats` for each model. In this section are shown the Lin's concordance correlation coefficient `CCC` (Lin 2000) for each, the coefficient of determination `r_squared` (R<sup>2</sup>) and the residual standard deviation `RSE`. In this output the models are sorted by from the higher `CCC` to the lower `CCC`, there is, from the more accurate to the less accurate model. In our case the more accurate model is the *Logistic* model. 

Right above is presented the sections `infection rate` and `Initial inoculum` . There are presented the estimated values for each models and their associated related statistics. They are also sorted by `CCC`.  

If you want to give a close look at the parameters you can call the `stats_all` using the `$` operator.

```{r}
head(f_lin$stats_all)
```


#### Predictions

You can see the model prediction by calling the `data` using the `$` operator like above. In there you'll find the data used for fitting (`y`) and prediction for each model (`predicted`). The column `linearized` contains the linearization of `y` for each model. And finally we have the residual in the column `residual`. 

```{r}
head(f_lin$data)
```

### Plonting using the function `plot_fit()`

Using the function `plot_fit()` you create a panel with the predictions for each model. You can also add some features of the `ggplot2` arsenal like themes and axis labels.


```{r}
plot_fit(f_lin,
         point_size = 2, 
         line_size = 1) +
  
  theme_minimal()+
  
  labs(x = "Time",
       y = "Disease intensity")
```

You can also select the model(s) you want to plot in the argument `models`. Here I selected just the *Logistic* model. 

```{r}
plot_fit(f_lin,
         point_size = 2, 
         line_size = 1,
         models = "Logistic") +
  
  theme_minimal()+
  
  labs(x = "Time",
       y = "Disease intensity")
```

## Using `fit_nlin()`

The `fit_nlin()` offers the possibility to fit models using nonlinear regression using the Levenberg-Marquardt algorithm. It works like `fit_lin()`, you can modify the starting values for the parameter `y0` and `r` in the `starting_par` argument. The output interpretation is analogous to the `fit_lin()`.

> NOTE: If you encounter messages saying "matrix at initial parameter estimates", try to modify the starting values for the parameters, that might solve the problem. 

`Plot_fit` also works for this function output.

```{r message=FALSE, warning=FALSE}
f_nlin <- fit_nlin(time = dpc_data$time,
                   y = dpc_data$random_y,
                   starting_par = list(y0 = 0.01, r = 0.03))

f_nlin
```


```{r}
plot_fit(f_nlin)+
  theme_minimal()
```

## Using `fit_nlin2()`

It is not always that a DPC reaches the maximum 100% intensity. When this does happens we often wont to estimate this value of maximum disease intensity and we usually denote it as `K`. Using the function `fin_lin2` we can fit the models and estimate the maximum disease intensity for your DPCs

Let's modify our data to have a maximum disease intensity of 0.8 (80%). We do that just multiplying the data to 0.8.


```{r}
dpc_data2 = dpc_data %>% 
  mutate(random_y = random_y*0.8)
```

Now we just put the data into the `fit_nlin2()` function. Here you can modify the stating parameter as well.

> NOTE: The exponential model is left aside here, becouse it doesn't have a maximum asymptote. 


See that the estimated value of `K` is just what we were expecting 0.8!

```{r message=FALSE, warning=FALSE}
f_nlin2 <- fit_nlin2(time = dpc_data2$time,
                     y = dpc_data2$random_y)
f_nlin2
```

## Using `multi_fitter`

Okay, now that we saw how to fit models to single epidemics, we are ready to see how to do it for more the one DPC. The `epifitter` also offers the option to you fit the models to various DPCs using the function `multi_fitter()`. You just need to put all your DPC data into a single `data.frame` and identify each one with strata columns.

### Data

Here I will create a `data.frame` containing three DPCs. Note that the I change the `y0` and `r` parameter to get different DPCs.  I used the Gompertz model to simulate these data, so we expect that the best model would be the same, just like we saw  above. 

I called the strata column 'DPC', so in it that we have the DPC 1, 2 and 3.

```{r}
epi1 <- sim_gompertz(N = 60, y0 = 0.001, dt = 5, r = 0.1, alpha = 0.4, n = 4)
epi2 <- sim_gompertz(N = 60, y0 = 0.001, dt = 5, r = 0.12, alpha = 0.4, n = 4)
epi3 <- sim_gompertz(N = 60, y0 = 0.003, dt = 5, r = 0.12, alpha = 0.4, n = 4)

multi_epidemic <- bind_rows(epi1,
                            epi2,
                            epi3,
                            .id = "DPC")
head(multi_epidemic)
```
### "Multi fitting"

To fit the model to all your DPCs, use the function `multi_fitter`. 

For that, inform the column in which are you time steps in the `time_col` argument. 

In the `intensity_col` inform the name of the column where is your disease intensity data (incidence, severity, ...). 

Inform you `data.frame` in the `data` argument. 

In strata_cols you have to inform the name of your strata column.In this example its name is "DPC", but you can have more than one strata column, you can inform that putting the columns names in a vector like this `c("strata1",strata2")`.

Informing only this arguments, it fit the models using linear regression of the linearized data, like in `fit_lin()`.

You can see the parameters calling `Parameters` using the `$` operator. The column `best model` gives the order of higher accuracy of the model. 

```{r}
multi_fit <- multi_fitter(time_col = "time",
                          intensity_col = "random_y",
                          data = multi_epidemic,
                          strata_cols = "DPC")


head(multi_fit$Parameters)
```

You can also see the data calling `Data`. 

```{r}
head(multi_fit$Data)
```


If you rather use nonlinear regression, set `TRUE` in the `nlim` argument. 

```{r}
multi_fit2 <- multi_fitter(time_col = "time",
                            intensity_col = "random_y",
                            data = multi_epidemic,
                            strata_cols = "DPC",
                            nlin = TRUE)
head(multi_fit2$Parameters)

```

### Estimate K?

You might want to estimate `K` for your data. To do that, set `nlin = TRUE` and `estimate_K = TRUE`. 

> NOTE: If you do not set both `TRUE`, `K` will not be estimated, because `nlin` defaut is `FALSE`. Also remember that when estimating K, we don't fit the *Exponential* model.

```{r}
multi_fit_K <- multi_fitter(time_col = "time",
                            intensity_col = "random_y",
                            data = multi_epidemic,
                            strata_cols = "DPC",
                            nlin = T,
                            estimate_K = T)


head(multi_fit_K$Parameters)
```

## Make graphics to compare curves and parameters

Use [`ggplot2`](https://ggplot2.tidyverse.org/) to produce elegant data visualizations of the model curves and the estimated parameters. 

### Curves

The original data and the predicted values for each model are in `multi_fit$Data`. See how we can plot the data and the predicted curves for each model and each DPC.

```{r}
multi_fit$Data %>%
  ggplot(aes(time, predicted, color = DPC)) +
  geom_point(aes(time, y), color = "gray") +
  geom_line(size  =1) +
  facet_grid(DPC~model, scales = "free_y") +
  theme_light()+
  coord_cartesian(ylim = c(0,1))
```

You can filter the data for specific model and plot it. To filter a model, use the function `filter()` from the `dplyr` package. 

```{r}
multi_fit$Data %>%
  filter(model == "Gompertz") %>%
  ggplot(aes(time, predicted, color = DPC)) +
  geom_point(aes(time, y),
    color = "gray",
    size = 2
  ) +
  geom_line(size = 1.2) +
  theme_light() +
  labs(
    x = "Time",
    y = "Disease Intensity"
  )
```

### Apparent infection rate

Access the estimated parameters calling `multi_fit$Parameters` and plot too.

```{r}
multi_fit$Parameters %>%
  filter(model == "Gompertz") %>%
  ggplot(aes(DPC, r)) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = r_ci_lwr, ymax = r_ci_upr),
    width = 0,
    size = 1
  ) +
  labs(
    x = "Time",
    y = "Apparent infection rate"
  ) +
  theme_light()
```




# References

Lin L (2000). A note on the concordance correlation coefficient. Biometrics 56: 324 - 325.
